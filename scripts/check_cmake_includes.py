#!/usr/bin/env python3
#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Verifies includes where defines from cmake configure_files are used.

This script scans files that are used as the input for a cmake `configure_file`
command and enumerates the `cmakedefine` declarations. It then scans the source
code to ensure that all files that make use of those defines #include the header
file generated by the `configure_file` command.

For details about the cmake `configure_file` command see
https://cmake.org/cmake/help/latest/command/configure_file.html
"""

import argparse
import fnmatch
import os
import pathlib
import re
import sys
from typing import (Collection, FrozenSet, Iterable, Mapping, NamedTuple,
                    Sequence, Tuple)


class ConfigureFileParserParseResult(NamedTuple):
  """Stores the result of parsing a `configure_file` file."""

  # The names of the variables created by #cmakedefine.
  defines: FrozenSet[str]


class ConfigureFileParser:
  """Parses a cmake `configure_file` file, enumerating its defines."""

  def __init__(self, path: pathlib.Path) -> None:
    """Initializes a new instance of this class.

    Arguments:
      path: The file to parse.
    """
    self.path = path

  def parse(self) -> ConfigureFileParserParseResult:
    """Parse the file.

    Returns:
      The data parsed from the file.
    """
    defines = set()

    define_pattern = re.compile(r"#cmakedefine\s+(?P<name>[^\s]+)")

    with self.path.open("rt", encoding="utf8") as f:
      for line in f:
        match = define_pattern.match(line)
        if match:
          defines.add(match.group("name"))

    return ConfigureFileParserParseResult(defines=frozenset(defines))


class CppFileParserResult(NamedTuple):
  """Stores the result of parsing a C++ file."""

  # The paths of the files included by #include.
  includes: FrozenSet[str]

  # The preprocessor variables used; the keys are the defines and the
  # corresponding values are the line numbers.
  defines_used: Mapping[str, int]


class CppFileParser:
  """Parser for C++ files to get the #include directives #define variables."""

  def __init__(self, path: pathlib.Path) -> None:
    """Initializes a new instance of this class.

    Arguments:
      path: The file to parse.
    """
    self.path = path

  def parse(self) -> CppFileParserResult:
    """Parse the file.

    Returns:
      The data parsed from the file.
    """
    includes = set()
    defines_used = {}

    include_pattern = re.compile(r"#(?i:include)\s+\"(?P<path>.+)\"$")
    directive_pattern = re.compile(r"#\s*(?P<cmd>\w+)\s+(?P<var>\w+)")

    with self.path.open("rt", encoding="utf8") as f:
      line_number = 0
      for line in f:
        line_number += 1
        include_match = include_pattern.match(line)
        if include_match:
          includes.add(include_match.group("path"))
          continue

        define_match = directive_pattern.match(line)
        if define_match:
          directive_name = define_match.group("cmd")
          if directive_name.lower() == "define":
            continue
          define_value = define_match.group("var")
          if define_value not in defines_used:
            defines_used[define_value] = line_number

    return CppFileParserResult(
        includes=frozenset(includes),
        defines_used=defines_used,
    )


class MissingInclude(NamedTuple):
  """Stores information about a missing include."""

  # The preprocessor variable that was used whose #include directive is missing.
  define: str

  # The string argument to the #include directive that was expected to be
  # present for the define but was missing.
  include: str

  # The line number of the file at which the define was used.
  line_number: int


class RequiredIncludesChecker:
  """Scans files for required includes for the defines that they use."""

  def __init__(self, defines: Mapping[str, str]) -> None:
    """Initializes a new instance of this class.

    Arguments:
      defines: The defines to verify have the correct includes; the keys of this
        mapping are the defines and the corresponding value is the required
        include for that define.
    """
    self.defines = defines

  def check_file(self, path: pathlib.Path) -> Tuple[MissingInclude]:
    """Checks the given file for missing includes.

    Arguments:
      path: The file to check.

    Returns:
      The missing includes; if empty then there were no missing includes and the
      check was successful; otherwise, each element describes an occurrence of
      a missing include.
    """
    cpp_file_parser = CppFileParser(path)
    parsed_cpp_file = cpp_file_parser.parse()

    missing_includes = []
    for define in parsed_cpp_file.defines_used:
      required_include = self.defines.get(define)
      if (required_include is not None
          and required_include not in parsed_cpp_file.includes):
        missing_include = MissingInclude(
            define=define,
            include=required_include,
            line_number=parsed_cpp_file.defines_used[define],
        )
        missing_includes.append(missing_include)

    return tuple(missing_includes)


class Logger:
  """Manages output printed by this application."""

  def __init__(self, quiet_mode: bool) -> None:
    """Initializes a new instance of this class.

    Arguments:
      quiet_mode: Whether or not "quiet mode" is enabed; if enabled, only
        critical information will be logged, with useful, but not critical,
        information like summary counts omitted from output.
    """
    self.quiet_mode = quiet_mode

  def missing_include(
      self,
      source_file: pathlib.Path,
      missing_include: MissingInclude,
  ) -> None:
    """Logs a missing include.

    Arguments:
      source_file: The file that is missing a required #include directive.
      missing_include: Information about the missing #include directive.
    """
    self.log(
        f"ERROR: {source_file}:{missing_include.line_number} "
        f"{missing_include.define} is used but the required include for it "
        f"is missing: {missing_include.include}")

  def summary(self, src_file_count: int, error_count: int) -> None:
    """Logs a summary line about the result of this application.

    Arguments:
      src_file_count: The number of source files scanned.
      error_count: The number of errors found in the scanned files.
    """
    if self.quiet_mode:
      return
    self.log(f"Scanned {src_file_count} files; {error_count} error(s) found.")

  def log(self, message: str) -> None:
    """Logs the given message."""
    print(message)


def run(
    cmake_configure_files: Mapping[pathlib.Path, str],
    source_files: Iterable[pathlib.Path],
    logger: Logger,
) -> int:
  """Checks source files for required includes for cmake configure files.

  Arguments:
    cmake_configure_files: The cmake configure_file files whose required
      includes to verify; the keys are the paths of the configure_file files and
      the corresponding values are the required #include directives in source
      files that use the cmake preprocessor variables defined therein.
    source_files: The paths of the source files to scan for required includes;
      each path will be read and all preprocessor variables usages that are
      defined in the given cmake_configure_files will be checked for a preceding
      required #include directive.
    logger: The logger to use to show information to the user.

  Returns:
    The number of errors found; therefore, a return value of 0 (zero) indicates
    that no errors were found in any of the given source files.
  """
  # Create a mapping from preprocessor variables to the include file required
  # for that variable by parsing the cmake configure_file files.
  defines = {}
  for cmake_configure_file in cmake_configure_files:
    required_include = cmake_configure_files[cmake_configure_file]
    configure_file_parser = ConfigureFileParser(cmake_configure_file)
    configure_file = configure_file_parser.parse()
    for define in configure_file.defines:
      defines[define] = required_include

  src_file_count = 0
  error_count = 0

  required_includes_checker = RequiredIncludesChecker(defines)
  for source_file in source_files:
    src_file_count += 1
    missing_includes = required_includes_checker.check_file(source_file)
    for missing_include in missing_includes:
      error_count += 1
      logger.missing_include(source_file, missing_include)

  logger.summary(src_file_count, error_count)
  return error_count


class ParsedArguments(NamedTuple):
  """The parsed command-line arguments."""

  # The mapping of paths of cmake configure_file files to their corresponding
  # required #include argument.
  cmake_configure_files: Mapping[pathlib.Path, str]

  # The files whose required includes to verify.
  source_files: Collection[pathlib.Path]

  # The logger to use to print output to the user.
  logger: Logger


class ArgumentParser:
  """The argument parser for this application."""

  def __init__(self) -> None:
    self.parser = argparse.ArgumentParser(
        usage="%(prog)s [options] <source_files>",
        description=__doc__,
        epilog="""Example: The cmake configure_file MyApp/config.h.in will be
        parsed and the preprocessor variables defined by cmakedefine commands
        therein will be recorded. Then, all .cc and .h files in the directories
        MyApp/src and MyApp/include, recursively, will be scanned. Any of the
        scanned files that use one or more of the preprocessor variables defined
        in the cmake configure_file will be verified to have the include line
        #include "config.h". Here is the command to perform this scan:
        %(prog)s --cmake_configure_file MyApp/config.h.in --required_include
        config.h --filename_include '*.cc' --filename_include '*.h'
        MyApp/src MyApp/include""",
    )

    self.source_files_argument = self.parser.add_argument(
        "source_files",
        nargs="+",
        help="""The source files to scan for required includes, typically .cc,
        .mm, and .h files. Any directories will have all files therein,
        recursively, scanned. At least one file or directory must be specified.
        """,
    )

    self.cmake_configure_file_argument = self.parser.add_argument(
        "--cmake_configure_file",
        action="append",
        required=True,
        help="""A cmake configure_file file whose cmakedefine declarations to
        verify have the required includes in the source files. Each occurrence
        of this argument must have a matching --required_include argument.
        This argument must be specified at least once.""",
    )

    self.required_include_argument = self.parser.add_argument(
        "--required_include",
        action="append",
        required=True,
        help="""The required argument to #include for the matching cmake
        configure_file specified to --cmake_configure_file.""",
    )

    self.parser.add_argument(
        "--filename_include",
        action="append",
        help="""A wildcard pattern to match against filenames; only files with
        names that match one or more of these wildcards will be scanned; if not
        specified at all then all files will be scanned. The recognized
        wildcards are "*" (asterisk) which matches zero or more characters, "?"
        (question mark) which matches zero or one characters, and "[seq]" where
        "seq" is a set of characters where one character must match. For a full
        specification see https://docs.python.org/3.6/library/fnmatch.html.
        Example: "*.txt" will include all files whose names end with ".txt" and
        "log[123].txt" will match the files "log1.txt", "log2.txt", and
        "log3.txt".""",
    )

    self.parser.add_argument(
        "--quiet",
        action="store_true",
        default=False,
        help="""Only print errors; do not print progress or summary
        information.""",
    )

  def parse_args(self, args: Sequence[str]) -> ParsedArguments:
    """Parse the given command-line arguments.

    Arguments:
      args: The arguments to parse; typically, this is sys.argv[1:].

    Returns:
      The parsed arguments.
    """
    parse_result = self.parser.parse_args(args=args)
    cmake_configure_files = dict(self._to_cmake_configure_files(parse_result))
    source_files = list(self._to_source_files(parse_result))
    logger = Logger(quiet_mode=parse_result.quiet)
    return ParsedArguments(
        cmake_configure_files=cmake_configure_files,
        source_files=source_files,
        logger=logger,
    )

  def _to_cmake_configure_files(
      self,
      parse_result: argparse.Namespace,
  ) -> Iterable[Tuple[pathlib.Path, str]]:
    """Extract the cmake configure files from a ParsedArguments object."""
    cmake_configure_files = tuple(parse_result.cmake_configure_file)
    required_includes = tuple(parse_result.required_include)

    if len(cmake_configure_files) != len(required_includes):
      self.parser.error(
          f"{self.cmake_configure_file_argument.option_strings[0]} "
          f"was specified {len(cmake_configure_files)} times but "
          f"{self.required_include_argument.option_strings[0]} was specified "
          f"{len(required_includes)} times and they must be specified the "
          "exact same number of times.")

    for i in range(len(cmake_configure_files)):
      yield (pathlib.Path(cmake_configure_files[i]), required_includes[i])

  def _to_source_files(
      self,
      parse_result: argparse.Namespace,
  ) -> Iterable[pathlib.Path]:
    """Extract the source file paths from a ParsedArguments object."""
    filename_patterns = tuple() if not parse_result.filename_include else tuple(
        re.compile(fnmatch.translate(pattern))
        for pattern in parse_result.filename_include)

    for source_path_str in parse_result.source_files:
      source_path = pathlib.Path(source_path_str)
      try:
        f = source_path.open("r")
      except IsADirectoryError:
        pass
      except OSError:
        # Assume that it is a file; a proper error will be reported later if
        # if cannot be opened for reading.
        yield source_path
      else:
        f.close()
        yield source_path
        continue

      for (dirpath, unused_dirnames, filenames) in os.walk(source_path):
        dirpath = pathlib.Path(dirpath)
        for filename in filenames:
          cur_file_path = dirpath / filename
          if not filename_patterns:
            yield cur_file_path
          else:
            for filename_pattern in filename_patterns:
              if filename_pattern.match(filename):
                yield cur_file_path
                break


def main() -> int:
  """The main entry point for this application.

  Returns:
    The exit code that would be appropriate to specify to sys.exit() based on
    the outcome of the application.
  """
  argument_parser = ArgumentParser()
  parsed_args = argument_parser.parse_args(sys.argv[1:])

  error_count = run(
      cmake_configure_files=parsed_args.cmake_configure_files,
      source_files=parsed_args.source_files,
      logger=parsed_args.logger,
  )

  return 0 if error_count == 0 else 1


if __name__ == "__main__":
  exit_code = main()
  sys.exit(exit_code)
